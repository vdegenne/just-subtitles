<!doctype html>
<html>

<head>
</head>

<body>
  <style>
    body {
      margin: 0;
      display: flex;
      align-items: flex-start;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
    }

    video::-webkit-media-controls-panel {
      /* display: flex !important;
      opacity: 1 !important; */
    }

    textarea {
      display: block;
      flex: 1;
      /* width: 70%; */
      font-size: 14px;
      height: 100%;
      margin: 0 auto;
      box-sizing: border-box;
      outline: none;
    }

    #saved {
      font-family: Arial, Helvetica, sans-serif;
      position: absolute;
      bottom: 0;
      left: 0;
    }

    .hide {
      display: none;
    }
  </style>

  <style>
    #video-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      justify-content: space-between;
    }

    #video-container>#controls {
      padding: 10px;
    }

    #video-container>#controls>button {
      width: 24px;
      height: 24px;
    }
  </style>
  <div id="video-container">
    <video id="video" src="/%videopath%" width=450></video>
    <div id="controls">
      <button onclick="video.width += 50">+</button>
      <button onclick="video.width -= 50">-</button>
    </div>
  </div>
  <textarea id="textarea" autofocus></textarea>
  <div id="saved" class="hide">saved</div>

  <script type="module">
    import { TimeCode, TimeCodeSpan } from '/timecode.js'

    window.onload = async () => {
      video.volume = .3;

      window.filebase = window.location.pathname.split('/').slice(2).join('/')
      fetch(`/files/${filebase}/captions.sbv`).then(async res => {
        if (res.status !== 200) {
          throw new Error('404')
        }
        textarea.value = await res.text()
      }).catch(err => { });
    }

    window.addEventListener('keydown', e => {
      // console.log(e.keyCode);

      /** just pause and play the video */
      if (e.shiftKey && e.keyCode === 32) {
        e.preventDefault()
        video.playUntil = undefined
        togglePlayVideo()
      }

      /** play a span */
      if (e.ctrlKey && e.keyCode === 32) {
        e.preventDefault()

        const { timecodeSpan } = getCursorTimeCodeSpanInformation()
        if (timecodeSpan) {
          playVideoSpan(
            timecodeSpan.start.toSeconds(),
            timecodeSpan.end ? timecodeSpan.end.toSeconds() : undefined
          )
        }
        else {
          togglePlayVideo()
        }
      }

      /* back 2 seconds */
      if (e.shiftKey && e.keyCode === 37) {
        e.preventDefault()
        video.currentTime -= 2
      }
      /* forward 2 seconds */
      if (e.shiftKey && e.keyCode === 39) {
        e.preventDefault()
        video.currentTime += 2
      }

      /** add timecode in the textarea */
      if ((e.shiftKey || e.altKey) && e.keyCode === 13) {
        e.preventDefault();
        const cursor = textarea.selectionStart
        const textValue = textarea.value.substring(0, cursor + 1)

        /** search the most appropriate position to insert the new timecode */
        let awaitingTimeCodeLastIndex,
          emptyLineLastIndex = textValue.lastIndexOf('\n\n') + 1
        let awaitingTimeCodeRegexp = /\d{3},\n/g
        while (awaitingTimeCodeRegexp.test(textValue)) {
          awaitingTimeCodeLastIndex = awaitingTimeCodeRegexp.lastIndex - 1
        }
        let insertionIndex = awaitingTimeCodeLastIndex || 0
        let fromEmptyLine = false
        if (emptyLineLastIndex > insertionIndex) {
          insertionIndex = emptyLineLastIndex
          fromEmptyLine = true
        }

        let timecode;
        if (e.shiftKey) {
          timecode = new TimeCode(video.currentTime)
          timecode.milliseconds = `${timecode.milliseconds}`[0] + '00'
        }
        else if (e.altKey) {
          const { timecodeSpan } = getCursorTimeCodeSpanInformation()
          timecode = timecodeSpan.end
        }

        /** finally insert the value */
        addTextAt(insertionIndex, timecode.toString() + (fromEmptyLine ? ',' : ''))
        textarea.selectionStart = cursor + 12 + (fromEmptyLine ? 1 : 0)
        textarea.selectionEnd = cursor + 12 + (fromEmptyLine ? 1 : 0)
      }

      /** offset the timecodes */
      if ((e.ctrlKey || e.altKey) && (e.keyCode === 37 || e.keyCode === 39)) {
        e.preventDefault()

        const cursor = textarea.selectionStart
        const { timecodeSpan, timecodeString, textareaStartIndex } = getCursorTimeCodeSpanInformation()
        const timecode = e.ctrlKey ? timecodeSpan.start : timecodeSpan.end

        /** left arrow : substract / right arrow : add */
        e.keyCode === 37 ? timecode.substract(100) : timecode.add(100)

        replaceText(
          textareaStartIndex,
          textareaStartIndex + timecodeString.length,
          timecodeSpan.toString()
        )
        textarea.selectionStart = cursor
        textarea.selectionEnd = cursor

        if (window.calibratePlayInterval) {
          clearTimeout(calibratePlayInterval)
          calibratePlayInterval = undefined
        }
        window.calibratePlayInterval = setTimeout(() => {
          if (e.ctrlKey) {
            playVideoSpan(timecodeSpan.start.toSeconds(), timecodeSpan.end ? timecodeSpan.end.toSeconds() : undefined)
          }
          else {
            playVideoSpan(timecodeSpan.end.toSeconds() - 2, timecodeSpan.end.toSeconds())
          }
        }, 500)
      }


      /** recenter textarea */
      if (e.ctrlKey && e.key === 'l') {
        e.preventDefault()
        // textarea.scrollTo(0, textarea.scrollTop + 50);
        refocusCenter()
      }

      /** saving */
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault()
        fetch(`/save-subtitles/${filebase}`, {
          method: 'POST',
          body: `subtitles=${textarea.value}`,
          headers: {
            'content-type': 'application/x-www-form-urlencoded'
          }
        }).then(res => {
          if (res.status !== 200) {
            throw new Error('something went wrong')
          }
          saved.classList.remove('hide');
          if (window.savedTimeout) {
            clearTimeout(window.savedTimeout)
            window.savedTimeout = undefined
          }
          window.savedTimeout = setTimeout(() => {
            saved.classList.add('hide');
          }, 5000);
        }).catch(err => {
          alert('something went wrong')
        })
      }
    });

    const getCursorTimeCodeSpanInformation = () => {
      const textvalue = textarea.value.substring(0, textarea.selectionStart + 8);
      const regexp = new RegExp(TimeCodeSpan.regexp, 'g');
      const results = textvalue.match(regexp);
      if (results) {
        return {
          timecodeString: results[results.length - 1],
          timecodeSpan: new TimeCodeSpan(results[results.length - 1]),
          textareaStartIndex: textvalue.lastIndexOf(results[results.length - 1])
        }
      }
      else {
        return {
          timecodeSpan: null,
          textareaStartIndex: -1
        }
      }
    }

    const seekToCursorStartTimeCode = () => {
      const timecode = getCursorTimeCodeSpan()
      if (timecode) {
        video.currentTime = timecode.start.toSeconds()
      }
    }


    let videoWhilePlayingInterval;
    const videoWhilePlaying = () => {
      if (!video.paused && video.playUntil && video.currentTime > video.playUntil) {
        pauseVideo()
      }
    }

    const playVideo = () => {
      video.play()
      videoWhilePlayingInterval = setInterval(videoWhilePlaying, 50)
    }
    const pauseVideo = () => {
      video.pause()
      clearInterval(videoWhilePlayingInterval)
      videoWhilePlayingInterval = undefined
    }
    const togglePlayVideo = () => {
      video.paused ? playVideo() : pauseVideo()
    }
    const playVideoSpan = (start, end) => {
      video.currentTime = start
      video.playUntil = end
      pauseVideo()
      playVideo()
    }


    /** textarea functions */
    // textarea.onkeydown = (e) => {
    //   refocusCenter()
    // }
    const refocusCenter = () => {
      textarea.scrollTo(0, 0)
      textarea.blur()
      textarea.focus()
    }
    const addTextAt = (position, text) => {
      textarea.value = textarea.value.substring(0, position)
        + text + textarea.value.substring(position);
    }

    const replaceText = (start, end, text) => {
      textarea.value = textarea.value.substring(0, start)
        + text + textarea.value.substring(end);
    }
  </script>
</body>

</html>